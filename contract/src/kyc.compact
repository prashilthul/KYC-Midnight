pragma language_version >= 0.20;

import CompactStandardLibrary;

/**
 * PII Data Struct - This is what the user "commits" to.
 */
struct Identity {
    birth_year: Uint<32>;
    country_hash: Bytes<32>;
    secret: Bytes<32>;
}

/**
 * The on-chain fingerprint of the identity.
 * commitment = persistentHash(Identity)
 */
export ledger kyc_commitment: Bytes<32>;

/**
 * Step 1: Registration
 * Links PII commitment to the blockchain.
 */
export circuit register(id: Identity, wallet_address: Bytes<32>): [] {
    kyc_commitment = disclose(persistentHash<Identity>(id));
}

/**
 * Step 2: Full Identity Ownership Proof
 */
export circuit prove_identity(id: Identity, wallet_address: Bytes<32>): [] {
    assert(kyc_commitment == persistentHash<Identity>(id), "Identity verification failed: Proof does not match commitment");
}

/**
 * Step 3: Dynamic Age Eligibility Proof
 */
export circuit prove_age_eligible(current_year: Uint<16>, min_age: Uint<16>, id: Identity, wallet_address: Bytes<32>): [] {
    assert(kyc_commitment == persistentHash<Identity>(id), "Identity mismatch");
    const cy32 = current_year as Uint<32>;
    const min32 = min_age as Uint<32>;
    assert(cy32 - id.birth_year >= min32, "Age Requirement Not Met: Access Denied");
}

/**
 * Step 4: Residency Verification
 */
export circuit prove_residency(required_country_hash: Bytes<32>, id: Identity, wallet_address: Bytes<32>): [] {
    assert(kyc_commitment == persistentHash<Identity>(id), "Identity mismatch");
    assert(id.country_hash == required_country_hash, "Residency Blocked: Country does not match requirements");
}

/**
 * Step 5: Generic Verification (The "Check" side)
 */
export circuit verify_claim(claimed_hash: Bytes<32>): [] {
    assert(kyc_commitment == claimed_hash, "Verification Failed: On-chain identity does not match provided proof");
}
